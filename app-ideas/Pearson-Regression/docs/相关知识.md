# 相关知识

## 1. 皮尔逊相关分析

### 1.1 基本概念

皮尔逊相关系数（Pearson Correlation Coefficient）是衡量两个变量之间线性关系强度和方向的统计量。它由卡尔·皮尔逊（Karl Pearson）在19世纪末提出。

### 1.2 数学公式

皮尔逊相关系数的计算公式为：

```
r = Σ[(xi - x̄)(yi - ȳ)] / √[Σ(xi - x̄)² × Σ(yi - ȳ)²]
```

其中：
- `r` 是皮尔逊相关系数
- `xi, yi` 是第i个数据点的x和y值
- `x̄, ȳ` 是x和y的样本均值
- `Σ` 表示求和

### 1.3 相关系数的含义

- **r = 1**: 完全正相关
- **r = -1**: 完全负相关
- **r = 0**: 无线性相关
- **|r| > 0.7**: 强相关
- **0.3 < |r| < 0.7**: 中等相关
- **|r| < 0.3**: 弱相关

### 1.4 应用场景

- 数据分析：探索变量间关系
- 机器学习：特征选择
- 科学研究：验证假设
- 商业分析：市场研究

## 2. JavaScript 实现皮尔逊算法

### 2.0 技术栈说明

**本实现完全使用原生JavaScript，无任何外部依赖：**

- ✅ **纯原生JavaScript** - 无需任何库或框架
- ✅ **ES6+ 语法** - 使用现代JavaScript特性
- ✅ **Canvas API** - 原生HTML5 Canvas进行绘图
- ✅ **无外部包** - 符合app-ideas项目要求

**为什么选择原生实现：**
1. **学习价值更高** - 深入理解算法原理
2. **性能更优** - 无额外库开销
3. **兼容性好** - 支持所有现代浏览器
4. **符合项目约束** - 满足"不依赖包"的要求

**可选的外部库（仅作参考，本项目不使用）：**
- Chart.js - 图表库
- D3.js - 数据可视化库
- Math.js - 数学计算库
- Plotly.js - 科学绘图库

### 2.1 基础实现

```javascript
/**
 * 计算皮尔逊相关系数
 * @param {number[]} x - x轴数据数组
 * @param {number[]} y - y轴数据数组
 * @returns {number} 皮尔逊相关系数
 */
function calculatePearsonCorrelation(x, y) {
    // 检查数据长度是否相等
    if (x.length !== y.length) {
        throw new Error('数据数组长度必须相等');
    }
    
    const n = x.length;
    if (n === 0) {
        throw new Error('数据数组不能为空');
    }
    
    // 计算均值
    const meanX = x.reduce((sum, val) => sum + val, 0) / n;
    const meanY = y.reduce((sum, val) => sum + val, 0) / n;
    
    // 计算分子：协方差
    let numerator = 0;
    for (let i = 0; i < n; i++) {
        numerator += (x[i] - meanX) * (y[i] - meanY);
    }
    
    // 计算分母：标准差乘积
    let sumSquaredDiffX = 0;
    let sumSquaredDiffY = 0;
    
    for (let i = 0; i < n; i++) {
        sumSquaredDiffX += Math.pow(x[i] - meanX, 2);
        sumSquaredDiffY += Math.pow(y[i] - meanY, 2);
    }
    
    const denominator = Math.sqrt(sumSquaredDiffX * sumSquaredDiffY);
    
    // 避免除零错误
    if (denominator === 0) {
        return 0;
    }
    
    return numerator / denominator;
}
```

### 2.2 优化版本（一步计算）

```javascript
/**
 * 优化的皮尔逊相关系数计算
 * @param {number[]} x - x轴数据数组
 * @param {number[]} y - y轴数据数组
 * @returns {number} 皮尔逊相关系数
 */
function calculatePearsonCorrelationOptimized(x, y) {
    if (x.length !== y.length || x.length === 0) {
        throw new Error('数据数组长度必须相等且不为空');
    }
    
    const n = x.length;
    
    // 计算均值
    const meanX = x.reduce((sum, val) => sum + val, 0) / n;
    const meanY = y.reduce((sum, val) => sum + val, 0) / n;
    
    // 一步计算所有需要的值
    let sumXY = 0, sumX2 = 0, sumY2 = 0;
    
    for (let i = 0; i < n; i++) {
        const diffX = x[i] - meanX;
        const diffY = y[i] - meanY;
        
        sumXY += diffX * diffY;
        sumX2 += diffX * diffX;
        sumY2 += diffY * diffY;
    }
    
    const denominator = Math.sqrt(sumX2 * sumY2);
    return denominator === 0 ? 0 : sumXY / denominator;
}
```

### 2.3 统计信息计算

```javascript
/**
 * 计算基本统计信息
 * @param {number[]} data - 数据数组
 * @returns {object} 包含均值、标准差等统计信息
 */
function calculateStatistics(data) {
    if (data.length === 0) {
        throw new Error('数据数组不能为空');
    }
    
    const n = data.length;
    const mean = data.reduce((sum, val) => sum + val, 0) / n;
    
    // 计算标准差
    const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;
    const standardDeviation = Math.sqrt(variance);
    
    return {
        mean: mean,
        standardDeviation: standardDeviation,
        variance: variance,
        count: n
    };
}
```

### 2.4 相关性解释

```javascript
/**
 * 解释相关系数的含义
 * @param {number} r - 皮尔逊相关系数
 * @returns {string} 相关性解释
 */
function interpretCorrelation(r) {
    const absR = Math.abs(r);
    
    if (absR >= 0.9) {
        return '极强相关';
    } else if (absR >= 0.7) {
        return '强相关';
    } else if (absR >= 0.5) {
        return '中等相关';
    } else if (absR >= 0.3) {
        return '弱相关';
    } else {
        return '极弱相关或无相关';
    }
}
```

## 3. 作图实现

### 3.0 绘图技术说明

**本实现使用原生HTML5 Canvas API：**

- ✅ **HTML5 Canvas** - 原生2D绘图API
- ✅ **无外部图表库** - 完全自定义实现
- ✅ **响应式设计** - 自适应画布大小
- ✅ **高性能渲染** - 直接操作像素

**Canvas API 优势：**
1. **完全控制** - 精确控制每个像素
2. **性能优秀** - 硬件加速支持
3. **无依赖** - 浏览器原生支持
4. **灵活性高** - 可实现任意复杂图形

**与外部库对比：**
```javascript
// 原生Canvas实现（本项目使用）
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
ctx.arc(x, y, radius, 0, 2 * Math.PI);
ctx.fill();

// Chart.js实现（本项目不使用）
new Chart(ctx, {
    type: 'scatter',
    data: { datasets: [{ data: points }] }
});

// D3.js实现（本项目不使用）
d3.select('svg')
  .selectAll('circle')
  .data(points)
  .enter()
  .append('circle')
  .attr('cx', d => xScale(d.x))
  .attr('cy', d => yScale(d.y));
```

### 3.1 使用 Canvas 绘制散点图

```javascript
/**
 * 散点图绘制类
 */
class ScatterPlot {
    constructor(canvasId, width = 800, height = 600) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = width;
        this.canvas.height = height;
        
        // 设置边距
        this.margin = { top: 40, right: 40, bottom: 60, left: 60 };
        this.plotWidth = width - this.margin.left - this.margin.right;
        this.plotHeight = height - this.margin.top - this.margin.bottom;
    }
    
    /**
     * 绘制散点图
     * @param {number[]} x - x轴数据
     * @param {number[]} y - y轴数据
     * @param {object} options - 绘图选项
     */
    drawScatterPlot(x, y, options = {}) {
        // 清除画布
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // 计算数据范围
        const xRange = this.calculateRange(x);
        const yRange = this.calculateRange(y);
        
        // 绘制坐标轴
        this.drawAxes(xRange, yRange);
        
        // 绘制数据点
        this.drawDataPoints(x, y, xRange, yRange, options);
        
        // 绘制标题和标签
        this.drawLabels(options);
    }
    
    /**
     * 计算数据范围
     */
    calculateRange(data) {
        const min = Math.min(...data);
        const max = Math.max(...data);
        const padding = (max - min) * 0.1; // 10% 边距
        
        return {
            min: min - padding,
            max: max + padding,
            range: max - min + 2 * padding
        };
    }
    
    /**
     * 绘制坐标轴
     */
    drawAxes(xRange, yRange) {
        this.ctx.strokeStyle = '#333';
        this.ctx.lineWidth = 2;
        
        // 绘制x轴
        this.ctx.beginPath();
        this.ctx.moveTo(this.margin.left, this.margin.top + this.plotHeight);
        this.ctx.lineTo(this.margin.left + this.plotWidth, this.margin.top + this.plotHeight);
        this.ctx.stroke();
        
        // 绘制y轴
        this.ctx.beginPath();
        this.ctx.moveTo(this.margin.left, this.margin.top);
        this.ctx.lineTo(this.margin.left, this.margin.top + this.plotHeight);
        this.ctx.stroke();
    }
    
    /**
     * 绘制数据点
     */
    drawDataPoints(x, y, xRange, yRange, options) {
        const pointColor = options.pointColor || '#3498db';
        const pointSize = options.pointSize || 4;
        
        this.ctx.fillStyle = pointColor;
        
        for (let i = 0; i < x.length; i++) {
            const plotX = this.margin.left + (x[i] - xRange.min) / xRange.range * this.plotWidth;
            const plotY = this.margin.top + this.plotHeight - (y[i] - yRange.min) / yRange.range * this.plotHeight;
            
            this.ctx.beginPath();
            this.ctx.arc(plotX, plotY, pointSize, 0, 2 * Math.PI);
            this.ctx.fill();
        }
    }
    
    /**
     * 绘制标签
     */
    drawLabels(options) {
        this.ctx.fillStyle = '#333';
        this.ctx.font = '14px Arial';
        this.ctx.textAlign = 'center';
        
        // 绘制标题
        if (options.title) {
            this.ctx.fillText(options.title, this.canvas.width / 2, 20);
        }
        
        // 绘制x轴标签
        if (options.xLabel) {
            this.ctx.fillText(options.xLabel, this.canvas.width / 2, this.canvas.height - 10);
        }
        
        // 绘制y轴标签
        if (options.yLabel) {
            this.ctx.save();
            this.ctx.translate(20, this.canvas.height / 2);
            this.ctx.rotate(-Math.PI / 2);
            this.ctx.fillText(options.yLabel, 0, 0);
            this.ctx.restore();
        }
    }
}
```

### 3.2 绘制回归线

```javascript
/**
 * 在散点图上绘制回归线
 * @param {number[]} x - x轴数据
 * @param {number[]} y - y轴数据
 * @param {object} xRange - x轴范围
 * @param {object} yRange - y轴范围
 */
drawRegressionLine(x, y, xRange, yRange) {
    // 计算回归线参数
    const regressionParams = this.calculateRegressionLine(x, y);
    
    // 计算回归线上的两个点
    const x1 = xRange.min;
    const y1 = regressionParams.slope * x1 + regressionParams.intercept;
    const x2 = xRange.max;
    const y2 = regressionParams.slope * x2 + regressionParams.intercept;
    
    // 绘制回归线
    this.ctx.strokeStyle = '#e74c3c';
    this.ctx.lineWidth = 2;
    this.ctx.beginPath();
    
    const plotX1 = this.margin.left + (x1 - xRange.min) / xRange.range * this.plotWidth;
    const plotY1 = this.margin.top + this.plotHeight - (y1 - yRange.min) / yRange.range * this.plotHeight;
    const plotX2 = this.margin.left + (x2 - xRange.min) / xRange.range * this.plotWidth;
    const plotY2 = this.margin.top + this.plotHeight - (y2 - yRange.min) / yRange.range * this.plotHeight;
    
    this.ctx.moveTo(plotX1, plotY1);
    this.ctx.lineTo(plotX2, plotY2);
    this.ctx.stroke();
    
    return regressionParams;
}

/**
 * 计算回归线参数
 */
calculateRegressionLine(x, y) {
    const n = x.length;
    const meanX = x.reduce((sum, val) => sum + val, 0) / n;
    const meanY = y.reduce((sum, val) => sum + val, 0) / n;
    
    let numerator = 0;
    let denominator = 0;
    
    for (let i = 0; i < n; i++) {
        numerator += (x[i] - meanX) * (y[i] - meanY);
        denominator += Math.pow(x[i] - meanX, 2);
    }
    
    const slope = numerator / denominator;
    const intercept = meanY - slope * meanX;
    
    return { slope, intercept };
}
```

### 3.3 使用示例

```javascript
// HTML结构（无需外部依赖）
// <canvas id="myCanvas" width="800" height="600"></canvas>

// 创建散点图实例（纯原生JavaScript）
const plot = new ScatterPlot('myCanvas', 800, 600);

// 示例数据
const xData = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const yData = [2, 4, 5, 7, 8, 10, 11, 13, 14, 16];

// 绘制散点图（原生Canvas API）
plot.drawScatterPlot(xData, yData, {
    title: '散点图示例',
    xLabel: 'X 轴',
    yLabel: 'Y 轴',
    pointColor: '#3498db',
    pointSize: 6
});

// 计算并显示相关系数（原生算法）
const correlation = calculatePearsonCorrelation(xData, yData);
console.log(`皮尔逊相关系数: ${correlation.toFixed(4)}`);
console.log(`相关性: ${interpretCorrelation(correlation)}`);
```

**完整HTML示例：**
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>皮尔逊相关分析</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        canvas { border: 1px solid #ccc; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>皮尔逊相关分析</h1>
    <canvas id="myCanvas" width="800" height="600"></canvas>
    <div id="results"></div>
    
    <script>
        // 这里放置所有JavaScript代码
        // 无需任何外部库或CDN链接
    </script>
</body>
</html>
```

### 3.4 高级功能

```javascript
/**
 * 添加网格线
 */
drawGrid(xRange, yRange, gridLines = 5) {
    this.ctx.strokeStyle = '#ddd';
    this.ctx.lineWidth = 1;
    
    // 绘制垂直网格线
    for (let i = 0; i <= gridLines; i++) {
        const x = this.margin.left + (i / gridLines) * this.plotWidth;
        this.ctx.beginPath();
        this.ctx.moveTo(x, this.margin.top);
        this.ctx.lineTo(x, this.margin.top + this.plotHeight);
        this.ctx.stroke();
    }
    
    // 绘制水平网格线
    for (let i = 0; i <= gridLines; i++) {
        const y = this.margin.top + (i / gridLines) * this.plotHeight;
        this.ctx.beginPath();
        this.ctx.moveTo(this.margin.left, y);
        this.ctx.lineTo(this.margin.left + this.plotWidth, y);
        this.ctx.stroke();
    }
}

/**
 * 添加图例
 */
drawLegend(legendItems) {
    const legendX = this.margin.left + this.plotWidth - 150;
    const legendY = this.margin.top + 20;
    
    this.ctx.font = '12px Arial';
    
    legendItems.forEach((item, index) => {
        // 绘制颜色块
        this.ctx.fillStyle = item.color;
        this.ctx.fillRect(legendX, legendY + index * 20, 15, 15);
        
        // 绘制标签
        this.ctx.fillStyle = '#333';
        this.ctx.fillText(item.label, legendX + 20, legendY + index * 20 + 12);
    });
}
```

## 4. 总结

### 4.1 技术栈总结

**本项目完全使用原生技术栈：**

| 技术 | 用途 | 优势 |
|------|------|------|
| **原生JavaScript** | 算法实现 | 无依赖、高性能、易理解 |
| **HTML5 Canvas** | 数据可视化 | 完全控制、硬件加速 |
| **CSS3** | 样式设计 | 现代布局、响应式设计 |
| **HTML5** | 页面结构 | 语义化、无障碍支持 |

**无外部依赖的优势：**
- ✅ **快速加载** - 无CDN依赖，离线可用
- ✅ **完全控制** - 自定义所有功能
- ✅ **学习价值** - 深入理解底层原理
- ✅ **兼容性好** - 支持所有现代浏览器

### 4.2 关键技术点

1. **数学计算**: 理解皮尔逊相关系数的数学原理
2. **算法实现**: 高效的JavaScript实现
3. **数据可视化**: Canvas绘图技术
4. **用户体验**: 交互式图表设计

### 4.3 扩展方向

1. **性能优化**: 大数据集处理
2. **交互功能**: 缩放、平移、悬停提示
3. **多种图表**: 直方图、箱线图等
4. **导出功能**: 图片保存、数据导出

### 4.4 学习建议

1. **先理解数学原理，再实现代码**
2. **从简单功能开始，逐步添加复杂特性**
3. **注重代码的可读性和可维护性**
4. **多测试不同数据集，确保算法正确性**

### 4.5 项目文件结构

```
Pearson-Regression/
├── index.html          # 主页面（纯HTML5）
├── style.css           # 样式文件（纯CSS3）
├── main.js             # 主逻辑（原生JavaScript）
└── docs/               # 文档目录
    ├── Pearson-Regression-App.md
    ├── Pearson-Regression-App-中文版.md
    └── 相关知识.md
```

**部署要求：**
- 无需Node.js或任何构建工具
- 无需包管理器（npm/yarn）
- 直接在浏览器中打开即可运行
- 支持本地文件系统访问
